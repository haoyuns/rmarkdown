# Spatial Analysis with `sf` and `raster` in R

## Reading spatial data
### Vector
Read in vector data with `sf` package and `st_read()`

- formats: Shapefiles, GeoJson, GPS, netCDF
- wirte vector data: `st_write()`

Vector spatial objects are data frames, while `sf` data frames have special properties:

- They include spatial metadata like the coordinate reference system
- The geometry is stored in a list column
  - the list column allows you to store far more information in a single variable
  - use `as_tibble()` to convert data frame to a tibble and print friendly

<img src="list1.png" width="600">

<img src="list2.png" width="600">

#### Extracting geometric information from vector layers
The functions `st_area()` and `st_length()` return the area and length of features.

But the result is a `units` object that requires a little additional processing, which means the vector result is accompanied by metadata describing the object's units. 

Therefore, code like this won't quite work:

```
# This will not work
result <- st_area(parks)
result > 30000
```

Instead you need to either remove the units with `unclass()`, or you need to convert `val`'s class to `units`, for example:

```
# This will work
val <- 30000
unclass(result) > val

# This will work
units(val) <- units(result)
result > val
```

#### Plotting vectors
The `plot()` function, when applied to `sf` objects, will create a set of maps, one for each attribute in your data. Instead, if you want to create a map of a single attribute you can extract that attribute using, as an example, `plot(data["variable"])`.

Frequently you just want to plot the raw geometry with no attribute color-coding, for this, you can use the `st_geometry()` function to extract the geometry and plot the result.

```
parks <- st_read("parks.shp")
areas <- st_area(parks)

# Filter to parks greater than 30000 (square meters)
big_parks <- parks %>% 
  filter(unclass(areas) > 30000)

# Plot just the geometry of big_parks
plot(st_geometry(big_parks))
```


### Raster
Read in raster data with `raster` package

- formats: GeoTIFF, Esri grids, ENVI grids, ERDAS grids
- read single-band rasters: `raster()`
- read multi-band rasters: `brick()`

Once you read in raster data, they'll be stored as objects with the class RasterLayer or RasterBrick.

```
canopy <- raster("canopy.tif")
manhattan <- brick("manhattan.tif")

# Get the class for the new objects
class(canopy)
[1] "RasterLayer"
attr(,"package")
[1] "raster"

class(manhattan)
[1] "RasterBrick"
attr(,"package")
[1] "raster"

# Identify how many layers each object has
nlayers(canopy)
[1] 1
nlayers(manhattan)
[1] 3
```
<img src="raster1.png" width="600">

#### Note when importing rasters...
Raster data can be very big depending on the extent and resolution (grid size). In order to deal with this, the `raster()` and `brick()` functions are designed to only read in the actual raster values as needed.

Therefore, `raster()` and `brick()` do not read in raster values by default. To conserve memory, raster values are imported only when required.

<img src="raster2.png" width="600">

If you use the `head()` function, the raster package will read in only the values needed, not the full set of values.

The raster values will be read in by default if you perform spatial analysis operations that require it, or you can read in the values from a raster manually with the function `getValues()`.

- Use `inMemory()` to tell if the raster values have been read into R. It will return FALSE if the values are not in memory

- Read the values with the `getValues()` function


#### Other functions
Instead of storing raster objects in data frames, the raster package stores spatial data in specially designed R classes that contain slots where the data and metadata are stored. The data and metadata can be accessed using a suite of functions. 

- `extent()` to get the minimum and maximum X and Y coordinates of the raster
- `ncell()` and `nlayers()` to get the total number of grid cells or layers, respectively
- `crs()` to get the coordinate reference system
- `writeRaster()` to write raster data

#### Creating quick maps of your rasters with `plot()` and `plotRGB()`
- use `plot()` for single-band rasters or to look at the individual layers in a multi-band raster
- use `plotRGB()` to create a **true color** map of a multi-layered object


## Preparing layers for spatial analysis
### Corrdinate reference system (CRS)
Vector and raster spatial data was created based on a specific CRS. Usually the spatial file has metadata defining the CRS, but sometimes there is not.

**Projected vs unprojected CRS**

- An unprojected CRS uses latitude and longitude coordinates and references the earth as a three-dimensional object
- A projected CRS uses X and Y coordinates as a two-dimensional representation of the earth

#### Print out the CRS
- `sf` package: `st_crs()` prints out a vector object's CRS
- `raster` package: `crs()` prints out a raster object's CRS

To determine if your object has a projected CRS, you can look at the first part of the result from `st_crs()` or `crs()` -- **if it begins with `+proj=longlat` then your CRS is unprojected**.

```
shape1 <- st_read("shape1.shp")
st_crs(shape1)
$epsg
[1] 4326

$proj4string
[1] "+proj=longlat +ellps=WGS84 +no_defs"

attr(,"class")
[1] "crs"
```

#### Define CRS with EPSG or proj4string
You can use either an EPSG or proj4string to define the CRS. A CRS might have both but might only need one.

- The **EPSG** code is a numeric representation of a CRS (e.g, 4326)
- The **proj4string** is a full set of parameters spelled out in a string (e.g., `+proj=longlat +ellps=WGS84 +no_defs`)

**With `st_crs()`**

- Define with the proj4string  
`st_crs(shape2) <- "+proj=longlat +ellps=WGS84 +no_defs"`

- Define with the EPSG code  
`st_crs(shape2) <- 4236`


**For a raster define with crs()**  
`crs(multiband) <- "+proj=utm +zone=18+datum=WGS84 +units=m +no_defs+ellps=WGS84 +towgs84=0,0,0"`

#### Change the CRS with `st_transform()` or `projectRaster()`
You mostly can't plot layers together if they don't have the same CRS.

- Use `st_transform()` to change the CRS for vectors
  - Note that you need `asText = TRUE` to force the `crs()` function from raster to output the CRS as a string.
  
- Use `projectRaster()` to change the CRS for rasters
  - Note that to use an EPSG with `projectRaster`, the syntax is `+init=epsg:32618`

```
# Transform the CRS for vector shapes
shape1_prj <- st_transform(shape1, crs = 32618)
shape1_prj <- st_transform(shape1, crs ="+proj=utm +zone=18 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")

# Transform CRS of one layer to match another layer
shape1_prj <- st_transform(shape1, crs = crs(singleband, asText = TRUE))

# Transform the CRS for a raster
singleband_prj <- projectRaster(singleband, crs = "+proj=utm +zone=18 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
singleband_prj <- projectRaster(singleband, crs = "+init=epsg:32618")
```

### Manipulating vector layers
One important difference between `dplyr` with and without spatial data is that the resulting data frames will include the geometry variable unless you explicitly drop it with `st_set_geometry(data, NULL)`. 

**Dropping geometry from a data frame:**

```
tree_cnt <- count(trees, hood) %>%
  st_set_geometry(NULL)
```

**Join spatial and non-spatial data with `inner_join()`**

```
# tree_sm is spatial, dat is non-spatial
res <- inner_join(tree_sm, dat, by = c("hood" = "hood_dat"))
```

**Simplify with `st_simplify()`**

- Compute the size in megabytes

```
library(pryr)
object_size(county)
489 kB
```

- Calculate number of vertices

```
# "cast" our polygons to bundles of points -- "MULTIPOINT" then count
pts <- st_cast(county$geometry, "MULTIPOINT")
sum(sapply(pts, length))
[1] 57886
```

**`st_simplify()`**

Tolerance controls simplification: bigger numbers mean more simplification, units are the units of the CRS. 

Use the `preserveTopology = TRUE` argument so that borders stay aligned.

`boro_simp <- st_simplify(boro, dTolerance = 500)`


### Converting `sf` objects between `sp` and raw coordinates
**Convert `sf` objects to `sp` with `as()`**

The class for `sp` objects is `Spatial`.

```
# Our sf object
polys <- st_read("polygons.shp")
class(polys)
[1] "sf"     "data.frame"

# Convert to Spatial object
polys_sp <- as(polys, Class = "Spatial")

class(polys_sp)
[1] "SpatialPolygonsDataFrame"
attr(,"package")
[1] "sp"
```

**Convert from `sp` to `sf` with `st_as_sf()`**

```
# Convert from sp to sf object
polys_sf <- st_as_sf(polys_sp)

class(polys_sf)
[1] "sf"         "data.frame"
```

#### Converting to and from coordinates
The `coords` argument specifies the coordinate columns and **must be in longitude,latitude or X, Y order**.

```
# Simple dataframe with coordinates
pts <- data.frame(
  ID = 1:2,
  lon = c(-73, -72),
  lat = c(41, 42)
  )

# Convert to an sf object
pts <- st_as_sf(pts, coords = c("lon", "lat"))

pts
# Simple feature collection with 2 features and 1 field
# geometry type:  POINT
# dimension:      XY
# bbox:           xmin: -73 ymin: 41 xmax: -72 ymax: 42
# epsg (SRID):    NA
# proj4string:    NA
# ID       geometry
# 1  1 POINT (-73 41)
# 2  2 POINT (-72 42)
```

#### Specify the CRS with either a proj4string or a EPSG code

```
# WGS 84 with a proj4string
st_as_sf(pts,
  coords = c("lon", "lat"),
  crs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
  )
```

With long/lat you can probably use EPSG = 4326 (WGS 84)

```
# WGS 84 with an EPSG code
st_as_sf(pts, coords = c("lon", "lat"), crs = 4326)
```

#### Write your points to a CSV with coordinates

If you want to convert your `sf` point objects to a data frame with coordinates, you can use the `st_write()` function with a hidden argument.

These are arguments associated with an external utility called GDAL, and so they're not in the R help.

- Writing to other spatial formats like shapefiles is easy with `st_write()`
- If you use `st_write()` with points and specify a CSV, coordinates won't be included
- Use a "hidden" argument, `layer_options` to write coordinates  
  `st_write(pts, "pts.csv", layer_options = "GEOMETRY=AS_XY")`

Note that `st_write()` can also be used to write lines and polygons, but it wouldn't make sense to write these out with coordinates in the same format.

### Manipulating raster layers



